using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing.Design;
using System.Globalization;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.Xrm.Sdk;

namespace MarkMpn.CustomActionToApiConverter
{
    class CustomAction
    {
        [Category("General")]
        [ReadOnly(true)]
        [Description("Display name of the Custom Action")]
        public string Name { get; set; }

        private bool ShouldSerializeName() => false;

        [Category("General")]
        [ReadOnly(true)]
        [DisplayName("Message Name")]
        [Description("SDK Message Name")]
        public string MessageName { get; set; }

        private bool ShouldSerializeMessageName() => false;

        [Category("General")]
        [ReadOnly(true)]
        [Description("Description of the Custom Action")]
        public string Description { get; set; }

        private bool ShouldSerializeDescription() => false;

        [Category("General")]
        [ReadOnly(true)]
        [DisplayName("Bound To")]
        [Description("The entity the Custom Action is bound to, or \"none\" for global actions")]
        public string PrimaryEntity { get; set; }

        private bool ShouldSerializePrimaryEntity() => false;

        [Category("Parameters")]
        [ReadOnly(true)]
        [DisplayName("Request Parameters")]
        [Description("The parameters that can be supplied to the Custom Action")]
        public ParameterCollection<RequestParameter> RequestParameters { get; set; }

        private bool ShouldSerializeRequestParameters() => false;

        [Category("Parameters")]
        [ReadOnly(true)]
        [DisplayName("Response Parameters")]
        [Description("The results that are generated by the Custom Action")]
        public ParameterCollection<ResponseParameter> ResponseParameters { get; set; }

        private bool ShouldSerializeResponseParameters() => false;

        [Browsable(false)]
        public List<PluginStep> PluginSteps { get; set; }

        [Category("Custom API Conversion")]
        [TypeConverter(typeof(MainPluginConverter))]
        [Description("The plugin to use for the main step of the Custom API after converting. This must be one of the plugins already added to a post-operation synchronous step")]
        public EntityReference Plugin { get; set; }

        [Category("Custom API Conversion")]
        [Description("Indicates if the Custom API should be created as private (hidden from metadata and documentation)")]
        public bool IsPrivate { get; set; }

        [Category("Custom API Conversion")]
        [Description("Indicates if the Custom API should be created as a function (requires a GET request via Web API rather than POST). Only Custom Actions with response parameters can be created as functions")]
        [TypeConverter(typeof(IsFunctionConverter))]
        public bool IsFunction { get; set; }

        [Category("Custom API Conversion")]
        [Description("Indicates what type of custom plugin steps can be registered against the message")]
        [TypeConverter(typeof(AllowedCustomProcessingStepTypeConverter))]
        public AllowedCustomProcessingStepType AllowedCustomProcessingStepType { get; set; }

        public List<AllowedCustomProcessingStepType> GetAllowedCustomProcessingStepType()
        {
            var values = new List<AllowedCustomProcessingStepType>();
            var remainingSteps = PluginSteps.Where(step => step.PluginId != Plugin?.Id || step.Stage != 40 || !step.Sync);

            // If there are no remaining steps we can selected None
            if (!remainingSteps.Any())
                values.Add(AllowedCustomProcessingStepType.None);

            // If there are no remaining sync steps we can select AsyncOnly
            if (!remainingSteps.Any(step => step.Sync))
                values.Add(AllowedCustomProcessingStepType.AsyncOnly);

            // We can always select SyncAndAsync
            values.Add(AllowedCustomProcessingStepType.SyncAndAsync);

            return values;
        }

        [Browsable(false)]
        public bool HasWorkflow { get; set; }
    }

    enum AllowedCustomProcessingStepType
    {
        None,

        [Description("Async Only")]
        AsyncOnly,

        [Description("Sync and Async")]
        SyncAndAsync
    }

    [TypeConverter(typeof(ExpandableCollectionConverter))]
    class ParameterCollection<T> : List<T> where T : Parameter
    {
        public ParameterCollection(IEnumerable<T> list) : base(list)
        {
        }
    }

    class ExpandableCollectionConverter : TypeConverter
    {
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            return destinationType == typeof(string);
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            var collection = (System.Collections.ICollection)value;
            return $"({collection.Count} parameter{(collection.Count == 1 ? "" : "s")})";
        }

        public override bool GetPropertiesSupported(ITypeDescriptorContext context) => true;

        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes)
        {
            var parameters = (IEnumerable<Parameter>)value;
            var properties = parameters.Select(param => new ExpandableCollectionItem(value, param));

            return new PropertyDescriptorCollection(properties.ToArray());
        }
    }

    class ExpandableCollectionItem : PropertyDescriptor
    {
        private readonly object _collection;
        private readonly Parameter _item;

        public ExpandableCollectionItem(object collection, Parameter item): base(item.Name, Attribute.GetCustomAttributes(item.GetType()))
        {
            _collection = collection;
            _item = item;
        }

        public override Type ComponentType => _collection.GetType();

        public override bool IsReadOnly => true;

        public override Type PropertyType => _item.GetType();

        public override bool CanResetValue(object component) => false;

        public override object GetValue(object component) => _item;

        public override void ResetValue(object component) => throw new NotImplementedException();

        public override void SetValue(object component, object value) => throw new NotImplementedException();

        public override bool ShouldSerializeValue(object component) => false;
    }

    [TypeConverter(typeof(ParameterConverter))]
    class Parameter
    {
        [Browsable(false)]
        public string Name { get; set; }

        [Browsable(false)]
        public Type Type { get; set; }

        [Browsable(false)]
        public string BindingInformation { get; set; }

        private bool ShouldSerializeBindingInformation() => false;

        [ReadOnly(true)]
        [Description("Indicates if this is an auto-generated parameter used to indicate the entity the request is bound to")]
        public bool IsBindingTarget { get; set; }

        private bool ShouldSerializeIsBindingTarget() => false;

        [ReadOnly(true)]
        [Description("For Entity and EntityReference type parameters, this indicates the name of the entity type that can be used")]
        public string BindingTargetType { get; set; }

        private bool ShouldSerializeBindingTargetType() => false;

        [ReadOnly(true)]
        [Description("A description of the parameter")]
        public string Description { get; set; }
    }

    class RequestParameter : Parameter
    {
        [ReadOnly(true)]
        [Description("Indicates if the parameter must be populated in each request")]
        public bool Required { get; set; }

        private bool ShouldSerializeRequired() => false;
    }

    class ResponseParameter : Parameter
    {
    }

    class ParameterConverter : ExpandableObjectConverter
    {
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            return destinationType == typeof(string);
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            var param = (Parameter)value;

            // TODO: Use XRM-specific language to match the type names shown in the Custom Action editor UI
            return param.Type.Name;
        }
    }

    class PluginStep
    {
        public Guid PluginId { get; set; }

        public string PluginName { get; set; }

        public int Stage { get; set; }

        public bool Sync { get; set; }
    }

    class MainPluginConverter : TypeConverter
    {
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) => true;

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) => true;

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            var action = (CustomAction)context.Instance;
            var postOpSyncPlugins = action.PluginSteps
                .Where(step => step.Sync && step.Stage == 40)
                .Select(step => new EntityReference("plugintype", step.PluginId) { Name = step.PluginName })
                .ToList();

            return new StandardValuesCollection(postOpSyncPlugins);
        }

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            return destinationType == typeof(string);
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            if (value == null)
                return null;

            if (value is string)
                return value;

            return ((EntityReference)value).Name;
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            var action = (CustomAction)context.Instance;
            var step = action.PluginSteps.First(s => s.PluginName == (string)value);
            return new EntityReference("plugintype", step.PluginId) { Name = step.PluginName };
        }
    }

    class IsFunctionConverter : TypeConverter
    {
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) => true;

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) => true;

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            var action = (CustomAction)context.Instance;

            if (action.ResponseParameters.Count > 0)
                return new StandardValuesCollection(new[] { true, false });

            return new StandardValuesCollection(new[] { false });
        }

        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType)
        {
            return destinationType == typeof(string);
        }

        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType)
        {
            if (value == null)
                return null;

            if (value.GetType() == destinationType)
                return value;

            return value.ToString();
        }

        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType)
        {
            return sourceType == typeof(string);
        }

        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value)
        {
            if (value == null)
                return null;

            if (value.GetType() == typeof(bool))
                return value;

            return Boolean.Parse((string)value);
        }
    }

    class AllowedCustomProcessingStepTypeConverter : TypeConverter
    {
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) => true;

        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) => true;

        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context)
        {
            var action = (CustomAction)context.Instance;
            return new StandardValuesCollection(action.GetAllowedCustomProcessingStepType());
        }
    }
}
